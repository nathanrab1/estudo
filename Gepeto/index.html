<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Engrenagens Planck.js - linhas radiais</title>
<style>
  body { background: #222; color: #eee; text-align: center; font-family: sans-serif; }
  canvas { background: #111; display: block; margin: 12px auto; border: 1px solid #333; }
  .controls { margin: 10px; }
  .controls label { margin: 0 10px; }
</style>
</head>
<body>
<h2>Engrenagens com dentes (linhas radiais) - Gear2 8px à direita</h2>

<div class="controls">
  <label>Velocidade:
    <input type="range" id="speedSlider" min="-5" max="5" step="0.1" value="1">
  </label>
  <label>Raio Gear 1:
    <input type="range" id="gear1Slider" min="1" max="5" step="0.1" value="3">
  </label>
  <label>Raio Gear 2:
    <input type="range" id="gear2Slider" min="0.5" max="3" step="0.1" value="1">
  </label>
</div>

<canvas id="canvas" width="600" height="400"></canvas>

<script src="https://cdn.jsdelivr.net/npm/planck-js@latest/dist/planck.min.js"></script>
<script>
const pl = planck;
const scale = 40; // 1 metro = 40 px

// Variáveis globais controladas pelos sliders
let gear1Radius = 3;
let gear2Radius = 1.0;
let motorSpeed = 1.0;
const teeth1 = 20;
const teeth2 = 14;

// Mundo
let world, gear1, gear2, joint1, joint2;
const ctx = document.getElementById('canvas').getContext('2d');
const baseX = 5.0, baseY = 5.0;

// Função para recriar o mundo e engrenagens
function initWorld() {
  world = new pl.World({gravity: pl.Vec2(0,0)});
  const ground = world.createBody();

  // Distância entre centros (somando raios)
  const centerDistance = gear1Radius + gear2Radius;
  const extraOffset = 8 / scale;

  // Criar engrenagens
  gear1 = world.createBody({ type:'dynamic', position: pl.Vec2(baseX, baseY) });
  gear1.createFixture(pl.Circle(gear1Radius), { density: 1.0, friction: 0.3 });

  gear2 = world.createBody({ type:'dynamic', position: pl.Vec2(baseX + centerDistance + extraOffset, baseY) });
  gear2.createFixture(pl.Circle(gear2Radius), { density: 1.0, friction: 0.3 });

  // Juntas
  joint1 = world.createJoint(pl.RevoluteJoint(
    { enableMotor: true, motorSpeed: motorSpeed, maxMotorTorque: 2000 },
    ground, gear1, gear1.getPosition()
  ));
  joint2 = world.createJoint(pl.RevoluteJoint({}, ground, gear2, gear2.getPosition()));

  // Relação de engrenagens (sentido oposto)
  world.createJoint(pl.GearJoint({}, gear1, gear2, joint1, joint2, gear2Radius/gear1Radius));
}

// Função para desenhar uma engrenagem
function drawGear(x, y, r, angle, teeth, color) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;

  // círculo externo
  ctx.beginPath();
  ctx.arc(0,0,r,0,Math.PI*2);
  ctx.stroke();

  // dentes (linhas radiais)
  for(let i=0;i<teeth;i++){
    const a = (i/teeth)*Math.PI*2;
    const x1 = Math.cos(a)*r;
    const y1 = Math.sin(a)*r;
    const x2 = Math.cos(a)*(r+8);
    const y2 = Math.sin(a)*(r+8);
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
  }

  ctx.restore();
}

// Loop de simulação
function draw() {
  ctx.clearRect(0,0,600,400);

  const pos1 = gear1.getPosition();
  const pos2 = gear2.getPosition();

  drawGear(pos1.x*scale, pos1.y*scale, gear1Radius*scale, gear1.getAngle(), teeth1, '#0f0');
  drawGear(pos2.x*scale, pos2.y*scale, gear2Radius*scale, gear2.getAngle(), teeth2, '#0ff');
}

function update() {
  world.step(1/60);
  draw();
  requestAnimationFrame(update);
}

// Sliders
document.getElementById('speedSlider').addEventListener('input', e => {
  motorSpeed = parseFloat(e.target.value);
  joint1.setMotorSpeed(motorSpeed);
});
document.getElementById('gear1Slider').addEventListener('input', e => {
  gear1Radius = parseFloat(e.target.value);
  initWorld();
});
document.getElementById('gear2Slider').addEventListener('input', e => {
  gear2Radius = parseFloat(e.target.value);
  initWorld();
});

// Inicialização
initWorld();
update();
</script>
</body>
</html>
